#!/bin/bash
# CT-084 Parachute Drop Pi Image Builder Script
# Industrial IoT Edge Node Builder for Rapid Deployment
# Author: Claude Agent 1 - Edge Computing Specialist
# Version: 1.0.0

set -euo pipefail

# Color output for better visibility
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BUILD_DIR="${SCRIPT_DIR}/build"
IMAGES_DIR="${BUILD_DIR}/images"
CACHE_DIR="${BUILD_DIR}/cache"
LOG_FILE="${BUILD_DIR}/build.log"

# CT-084 Configuration
CT084_VERSION="1.0.0"
CT084_HOSTNAME_PREFIX="ct084-drop"
CT084_PROJECT_NAME="Parachute Drop System"
CT084_DEPLOYMENT_TYPE="industrial-edge"

# Pi Configuration
PI_OS_VERSION="2024-03-15-raspios-bookworm-arm64-lite"
PI_OS_URL="https://downloads.raspberrypi.org/raspios_lite_arm64/images/raspios_lite_arm64-2024-03-15/2024-03-15-raspios-bookworm-arm64-lite.img.xz"
PI_MEMORY_SPLIT="64"  # GPU memory split
PI_ENABLE_SSH="true"
PI_ENABLE_I2C="true"
PI_ENABLE_SPI="true"
PI_ENABLE_CAMERA="false"

# Industrial IoT Stack Configuration
STACK_REPO_URL="https://github.com/industrial-iot-stack/industrial-iot-stack.git"
STACK_BRANCH="main"

# Logging function
log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    case "$level" in
        "INFO")  echo -e "${GREEN}[INFO]${NC}  $timestamp - $message" | tee -a "$LOG_FILE" ;;
        "WARN")  echo -e "${YELLOW}[WARN]${NC}  $timestamp - $message" | tee -a "$LOG_FILE" ;;
        "ERROR") echo -e "${RED}[ERROR]${NC} $timestamp - $message" | tee -a "$LOG_FILE" ;;
        "DEBUG") echo -e "${BLUE}[DEBUG]${NC} $timestamp - $message" | tee -a "$LOG_FILE" ;;
    esac
}

# Error handling
error_exit() {
    log "ERROR" "$1"
    exit 1
}

# Check dependencies
check_dependencies() {
    log "INFO" "Checking build dependencies..."
    
    local deps=("curl" "wget" "unzip" "xz-utils" "parted" "kpartx" "qemu-user-static" "binfmt-support")
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            error_exit "Missing dependency: $dep"
        fi
    done
    
    # Check if running as root (required for mounting)
    if [[ $EUID -ne 0 ]]; then
        error_exit "This script must be run as root for image mounting"
    fi
    
    log "INFO" "All dependencies satisfied"
}

# Setup build environment
setup_build_env() {
    log "INFO" "Setting up build environment..."
    
    # Create build directories
    mkdir -p "$BUILD_DIR" "$IMAGES_DIR" "$CACHE_DIR"
    
    # Initialize log file
    cat > "$LOG_FILE" << EOF
CT-084 Parachute Drop Pi Image Builder
=====================================
Build started: $(date)
Version: $CT084_VERSION
EOF
    
    log "INFO" "Build environment ready"
}

# Download Pi OS image
download_pi_image() {
    log "INFO" "Downloading Raspberry Pi OS image..."
    
    local image_file="$CACHE_DIR/$(basename "$PI_OS_URL")"
    local extracted_image="$IMAGES_DIR/raspios-base.img"
    
    # Download if not cached
    if [[ ! -f "$image_file" ]]; then
        log "INFO" "Downloading from $PI_OS_URL..."
        wget -O "$image_file" "$PI_OS_URL" || error_exit "Failed to download Pi OS image"
    else
        log "INFO" "Using cached Pi OS image"
    fi
    
    # Extract image
    log "INFO" "Extracting Pi OS image..."
    xz -dc "$image_file" > "$extracted_image" || error_exit "Failed to extract Pi OS image"
    
    log "INFO" "Pi OS image ready: $extracted_image"
    echo "$extracted_image"
}

# Mount Pi image
mount_pi_image() {
    local image_file="$1"
    local mount_point="$BUILD_DIR/mount"
    
    log "INFO" "Mounting Pi image..."
    
    # Create mount point
    mkdir -p "$mount_point"
    
    # Setup loop device
    local loop_device=$(losetup -fP "$image_file")
    log "DEBUG" "Loop device: $loop_device"
    
    # Mount partitions
    mount "${loop_device}p2" "$mount_point" || error_exit "Failed to mount root partition"
    mount "${loop_device}p1" "$mount_point/boot" || error_exit "Failed to mount boot partition"
    
    # Setup chroot environment
    mount --bind /dev "$mount_point/dev"
    mount --bind /proc "$mount_point/proc"
    mount --bind /sys "$mount_point/sys"
    
    log "INFO" "Pi image mounted at $mount_point"
    echo "$mount_point"
}

# Configure Pi system
configure_pi_system() {
    local mount_point="$1"
    
    log "INFO" "Configuring Pi system for CT-084..."
    
    # Configure boot settings
    cat >> "$mount_point/boot/config.txt" << EOF

# CT-084 Parachute Drop System Configuration
# Generated by CT-084 Pi Image Builder v$CT084_VERSION

# Memory split for headless operation
gpu_mem=$PI_MEMORY_SPLIT

# Enable I2C for industrial sensors
dtparam=i2c_arm=on

# Enable SPI for industrial communication
dtparam=spi=on

# Enable UART for industrial protocols
enable_uart=1

# USB power configuration for industrial devices
max_usb_current=1

# Reduce wear on SD card
dtoverlay=disable-bt

# Industrial temperature monitoring
dtparam=temp_limit=80

# CT-084 Identification
device_tree_address=0x1234
EOF

    # Configure cmdline for industrial operation
    sed -i 's/console=serial0,115200 //' "$mount_point/boot/cmdline.txt"
    
    # Enable SSH
    if [[ "$PI_ENABLE_SSH" == "true" ]]; then
        touch "$mount_point/boot/ssh"
        log "INFO" "SSH enabled"
    fi
    
    # Configure hostname
    local hostname="${CT084_HOSTNAME_PREFIX}-$(date +%Y%m%d%H%M%S)"
    echo "$hostname" > "$mount_point/etc/hostname"
    
    # Update hosts file
    sed -i "s/127.0.1.1.*raspberrypi/127.0.1.1\t$hostname/" "$mount_point/etc/hosts"
    
    log "INFO" "Pi system configured for CT-084"
}

# Install CT-084 software stack
install_ct084_stack() {
    local mount_point="$1"
    
    log "INFO" "Installing CT-084 software stack..."
    
    # Create CT-084 directory structure
    mkdir -p "$mount_point/opt/ct084"
    mkdir -p "$mount_point/var/log/ct084"
    mkdir -p "$mount_point/etc/ct084"
    
    # Install Python dependencies
    chroot "$mount_point" /bin/bash << 'EOF'
apt-get update
apt-get install -y python3-pip python3-venv git curl wget

# Create virtual environment for CT-084
python3 -m venv /opt/ct084/venv
source /opt/ct084/venv/bin/activate

# Install core Python packages
pip install --upgrade pip
pip install requests paho-mqtt opcua psutil schedule
pip install Phidget22 numpy pandas
pip install flask flask-cors websocket-client
pip install python-json-logger structlog

# Install Node.js and Node-RED
curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
apt-get install -y nodejs

# Install Node-RED
npm install -g --unsafe-perm node-red
npm install -g --unsafe-perm node-red-admin

# Install essential Node-RED nodes
cd /root/.node-red 2>/dev/null || mkdir -p /root/.node-red && cd /root/.node-red
npm install node-red-contrib-opcua
npm install node-red-contrib-modbus
npm install node-red-dashboard
npm install node-red-contrib-influxdb
npm install node-red-contrib-mqtt-broker
npm install node-red-contrib-phidget22
npm install node-red-contrib-buffer-parser
npm install node-red-contrib-cron-plus

# Cleanup
apt-get autoremove -y
apt-get clean
EOF
    
    log "INFO" "CT-084 software stack installed"
}

# Install CT-084 discovery agent
install_discovery_agent() {
    local mount_point="$1"
    
    log "INFO" "Installing CT-084 Enhanced Discovery Agent..."
    
    # Copy discovery agent (will be created in next step)
    cp "$SCRIPT_DIR/ct084-discovery-agent.py" "$mount_point/opt/ct084/"
    cp "$SCRIPT_DIR/ct084-config.json" "$mount_point/etc/ct084/"
    
    # Create discovery agent service
    cat > "$mount_point/etc/systemd/system/ct084-discovery.service" << EOF
[Unit]
Description=CT-084 Enhanced Discovery Agent
After=network.target
Wants=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/opt/ct084
Environment=PYTHONPATH=/opt/ct084
ExecStart=/opt/ct084/venv/bin/python /opt/ct084/ct084-discovery-agent.py
Restart=always
RestartSec=10
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
EOF
    
    # Enable service
    chroot "$mount_point" systemctl enable ct084-discovery.service
    
    log "INFO" "CT-084 Discovery Agent installed and enabled"
}

# Create CT-084 health monitor
create_health_monitor() {
    local mount_point="$1"
    
    log "INFO" "Creating CT-084 health monitoring system..."
    
    cat > "$mount_point/opt/ct084/health-monitor.py" << 'EOF'
#!/usr/bin/env python3
"""
CT-084 Parachute Drop System Health Monitor
Monitors system health and reports to central monitoring
"""

import json
import time
import logging
import psutil
import subprocess
from datetime import datetime
from pathlib import Path

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/var/log/ct084/health-monitor.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger('CT084-Health')

class CT084HealthMonitor:
    def __init__(self):
        self.config_file = Path('/etc/ct084/ct084-config.json')
        self.health_file = Path('/var/log/ct084/health-status.json')
        self.load_config()
        
    def load_config(self):
        try:
            with open(self.config_file, 'r') as f:
                self.config = json.load(f)
        except Exception as e:
            logger.error(f"Failed to load config: {e}")
            self.config = {"device_id": "ct084-unknown"}
    
    def get_system_health(self):
        health = {
            'timestamp': datetime.now().isoformat(),
            'device_id': self.config.get('device_id', 'unknown'),
            'system': {
                'cpu_percent': psutil.cpu_percent(interval=1),
                'memory_percent': psutil.virtual_memory().percent,
                'disk_percent': psutil.disk_usage('/').percent,
                'temperature': self.get_cpu_temperature(),
                'uptime': self.get_uptime()
            },
            'services': self.check_services(),
            'network': self.check_network(),
            'phidgets': self.check_phidgets()
        }
        return health
    
    def get_cpu_temperature(self):
        try:
            result = subprocess.run(['vcgencmd', 'measure_temp'], 
                                  capture_output=True, text=True)
            temp_str = result.stdout.strip()
            return float(temp_str.replace('temp=', '').replace("'C", ''))
        except:
            return None
    
    def get_uptime(self):
        try:
            return time.time() - psutil.boot_time()
        except:
            return None
    
    def check_services(self):
        services = ['ct084-discovery', 'nodered']
        status = {}
        
        for service in services:
            try:
                result = subprocess.run(['systemctl', 'is-active', service],
                                      capture_output=True, text=True)
                status[service] = result.stdout.strip() == 'active'
            except:
                status[service] = False
        
        return status
    
    def check_network(self):
        try:
            result = subprocess.run(['ping', '-c', '1', '8.8.8.8'],
                                  capture_output=True, text=True)
            return result.returncode == 0
        except:
            return False
    
    def check_phidgets(self):
        # This will be implemented with the discovery agent
        return {"status": "checking"}
    
    def run_health_check(self):
        health = self.get_system_health()
        
        # Save health status
        with open(self.health_file, 'w') as f:
            json.dump(health, f, indent=2)
        
        # Log critical issues
        if health['system']['cpu_percent'] > 80:
            logger.warning(f"High CPU usage: {health['system']['cpu_percent']}%")
        
        if health['system']['temperature'] and health['system']['temperature'] > 70:
            logger.warning(f"High temperature: {health['system']['temperature']}°C")
        
        return health

if __name__ == '__main__':
    monitor = CT084HealthMonitor()
    
    while True:
        try:
            health = monitor.run_health_check()
            logger.info(f"Health check completed - CPU: {health['system']['cpu_percent']}%")
            time.sleep(60)  # Check every minute
        except KeyboardInterrupt:
            logger.info("Health monitor stopped")
            break
        except Exception as e:
            logger.error(f"Health check failed: {e}")
            time.sleep(30)
EOF
    
    # Create health monitor service
    cat > "$mount_point/etc/systemd/system/ct084-health.service" << EOF
[Unit]
Description=CT-084 Health Monitor
After=network.target
Wants=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/opt/ct084
Environment=PYTHONPATH=/opt/ct084
ExecStart=/opt/ct084/venv/bin/python /opt/ct084/health-monitor.py
Restart=always
RestartSec=30
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
EOF
    
    # Enable health monitor
    chroot "$mount_point" systemctl enable ct084-health.service
    
    log "INFO" "CT-084 health monitor created and enabled"
}

# Create default configuration
create_default_config() {
    local mount_point="$1"
    
    log "INFO" "Creating default CT-084 configuration..."
    
    local hostname=$(cat "$mount_point/etc/hostname")
    
    cat > "$mount_point/etc/ct084/ct084-config.json" << EOF
{
    "device_info": {
        "device_id": "$hostname",
        "device_type": "CT-084-Parachute-Drop",
        "version": "$CT084_VERSION",
        "deployment_type": "$CT084_DEPLOYMENT_TYPE",
        "build_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    },
    "network": {
        "discovery_enabled": true,
        "discovery_port": 8084,
        "mqtt_broker": "localhost",
        "mqtt_port": 1883,
        "opcua_endpoint": "opc.tcp://localhost:4840"
    },
    "sensors": {
        "phidget_hub_enabled": true,
        "auto_discovery": true,
        "scan_interval": 30,
        "data_retention_hours": 168
    },
    "edge_computing": {
        "node_red_enabled": true,
        "node_red_port": 1880,
        "local_processing": true,
        "buffering_enabled": true
    },
    "monitoring": {
        "health_check_interval": 60,
        "log_level": "INFO",
        "metrics_enabled": true,
        "alert_thresholds": {
            "cpu_percent": 80,
            "memory_percent": 85,
            "temperature_celsius": 70,
            "disk_percent": 90
        }
    },
    "deployment": {
        "auto_update_enabled": false,
        "remote_access_enabled": true,
        "backup_enabled": true,
        "factory_reset_pin": 18
    }
}
EOF
    
    # Set proper permissions
    chroot "$mount_point" /bin/bash << 'EOF'
chown -R root:root /opt/ct084
chown -R root:root /etc/ct084
chown -R root:root /var/log/ct084
chmod +x /opt/ct084/health-monitor.py
EOF
    
    log "INFO" "Default CT-084 configuration created"
}

# Unmount Pi image
unmount_pi_image() {
    local mount_point="$1"
    
    log "INFO" "Unmounting Pi image..."
    
    # Unmount in reverse order
    umount "$mount_point/sys" 2>/dev/null || true
    umount "$mount_point/proc" 2>/dev/null || true
    umount "$mount_point/dev" 2>/dev/null || true
    umount "$mount_point/boot" 2>/dev/null || true
    umount "$mount_point" 2>/dev/null || true
    
    # Detach loop device
    losetup -D 2>/dev/null || true
    
    log "INFO" "Pi image unmounted"
}

# Create final image
create_final_image() {
    local base_image="$1"
    local final_image="$IMAGES_DIR/ct084-parachute-drop-v${CT084_VERSION}.img"
    
    log "INFO" "Creating final CT-084 image..."
    
    # Copy base image to final image
    cp "$base_image" "$final_image"
    
    # Compress image
    log "INFO" "Compressing final image..."
    xz -T 0 -z "$final_image"
    
    local compressed_image="${final_image}.xz"
    local image_size=$(du -h "$compressed_image" | cut -f1)
    
    log "INFO" "Final CT-084 image created: $compressed_image ($image_size)"
    
    # Generate checksums
    cd "$IMAGES_DIR"
    sha256sum "$(basename "$compressed_image")" > "$(basename "$compressed_image").sha256"
    
    # Create build manifest
    cat > "$IMAGES_DIR/ct084-build-manifest.json" << EOF
{
    "build_info": {
        "version": "$CT084_VERSION",
        "build_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
        "builder": "CT-084 Pi Image Builder",
        "project": "$CT084_PROJECT_NAME"
    },
    "image_info": {
        "filename": "$(basename "$compressed_image")",
        "size_bytes": $(stat -c%s "$compressed_image"),
        "size_human": "$image_size",
        "checksum": "$(cat "$(basename "$compressed_image").sha256" | cut -d' ' -f1)"
    },
    "pi_config": {
        "os_version": "$PI_OS_VERSION",
        "memory_split": "$PI_MEMORY_SPLIT",
        "ssh_enabled": $PI_ENABLE_SSH,
        "i2c_enabled": $PI_ENABLE_I2C,
        "spi_enabled": $PI_ENABLE_SPI
    },
    "software_stack": {
        "python_version": "3.11",
        "node_version": "18.x",
        "node_red_version": "latest",
        "discovery_agent": "enhanced",
        "health_monitoring": "enabled"
    }
}
EOF
    
    echo "$compressed_image"
}

# Generate deployment documentation
generate_deployment_docs() {
    local final_image="$1"
    
    log "INFO" "Generating deployment documentation..."
    
    cat > "$IMAGES_DIR/CT084-DEPLOYMENT-GUIDE.md" << EOF
# CT-084 Parachute Drop System - Deployment Guide

## Overview
This guide covers the deployment of CT-084 Parachute Drop Pi edge nodes for rapid industrial IoT deployment.

**Image Information:**
- Version: $CT084_VERSION
- Build Date: $(date -u +%Y-%m-%dT%H:%M:%SZ)
- File: $(basename "$final_image")
- Project: $CT084_PROJECT_NAME

## Prerequisites
- Raspberry Pi 4 Model B (4GB RAM recommended)
- 32GB+ Industrial SD Card (Class 10 or better)
- Phidget VINT Hub (HUB0000)
- Industrial sensors (temperature, humidity, pressure, etc.)
- Network connectivity (Ethernet preferred)

## Quick Deployment Steps

### 1. Flash SD Card
\`\`\`bash
# Flash the image to SD card (replace /dev/sdX with your SD card)
xz -dc $(basename "$final_image") | sudo dd of=/dev/sdX bs=4M status=progress conv=fsync
\`\`\`

### 2. Initial Boot
1. Insert SD card into Pi
2. Connect Ethernet cable
3. Connect Phidget VINT Hub to USB
4. Power on Pi
5. Wait 2-3 minutes for initial boot

### 3. Find Pi on Network
\`\`\`bash
# Scan for CT-084 devices
nmap -sn 192.168.1.0/24 | grep -B2 -A2 "ct084"
\`\`\`

### 4. Initial Configuration
\`\`\`bash
# SSH into the Pi (default password: raspberry)
ssh pi@<pi-ip-address>

# Change default password
passwd

# Update hostname if needed
sudo hostnamectl set-hostname ct084-drop-<location>
\`\`\`

### 5. Verify Services
\`\`\`bash
# Check CT-084 services
sudo systemctl status ct084-discovery
sudo systemctl status ct084-health
sudo systemctl status nodered

# View discovery agent logs
sudo journalctl -u ct084-discovery -f
\`\`\`

## Service URLs
- Node-RED: http://<pi-ip>:1880
- Health Monitor: http://<pi-ip>:8084/health
- Discovery Agent: http://<pi-ip>:8084/discovery

## Configuration Files
- Main config: \`/etc/ct084/ct084-config.json\`
- Node-RED flows: \`/root/.node-red/flows.json\`
- Health logs: \`/var/log/ct084/health-monitor.log\`

## Sensor Connection
1. Connect Phidget sensors to VINT Hub ports
2. Power cycle Pi to detect new sensors
3. Check discovery agent logs for sensor detection
4. Verify sensor data in Node-RED dashboard

## Troubleshooting
- Check system health: \`curl http://localhost:8084/health\`
- View all logs: \`sudo journalctl -xe\`
- Restart services: \`sudo systemctl restart ct084-discovery\`
- Factory reset: Hold GPIO pin 18 during boot

## Support
For technical support, check the build logs and system documentation.

Built with CT-084 Pi Image Builder v$CT084_VERSION
EOF
    
    log "INFO" "Deployment documentation generated"
}

# Main build function
main() {
    log "INFO" "Starting CT-084 Parachute Drop Pi Image Builder v$CT084_VERSION"
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --clean)
                log "INFO" "Cleaning build directory..."
                rm -rf "$BUILD_DIR"
                ;;
            --no-download)
                SKIP_DOWNLOAD=true
                ;;
            --help)
                echo "CT-084 Pi Image Builder"
                echo "Usage: $0 [--clean] [--no-download] [--help]"
                echo ""
                echo "Options:"
                echo "  --clean       Clean build directory before building"
                echo "  --no-download Skip downloading base Pi image"
                echo "  --help        Show this help message"
                exit 0
                ;;
            *)
                error_exit "Unknown option: $1"
                ;;
        esac
        shift
    done
    
    # Build process
    check_dependencies
    setup_build_env
    
    # Download and prepare base image
    if [[ "${SKIP_DOWNLOAD:-false}" != "true" ]]; then
        local base_image=$(download_pi_image)
    else
        local base_image="$IMAGES_DIR/raspios-base.img"
        if [[ ! -f "$base_image" ]]; then
            error_exit "Base image not found: $base_image"
        fi
    fi
    
    # Mount and configure image
    local mount_point=$(mount_pi_image "$base_image")
    
    # Ensure cleanup on exit
    trap "unmount_pi_image '$mount_point'" EXIT
    
    # Configure Pi system
    configure_pi_system "$mount_point"
    install_ct084_stack "$mount_point"
    install_discovery_agent "$mount_point"
    create_health_monitor "$mount_point"
    create_default_config "$mount_point"
    
    # Unmount and create final image
    unmount_pi_image "$mount_point"
    trap - EXIT  # Remove exit trap
    
    local final_image=$(create_final_image "$base_image")
    generate_deployment_docs "$final_image"
    
    log "INFO" "CT-084 Pi Image Builder completed successfully!"
    log "INFO" "Final image: $final_image"
    log "INFO" "Deployment guide: $IMAGES_DIR/CT084-DEPLOYMENT-GUIDE.md"
    
    return 0
}

# Run main function
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi