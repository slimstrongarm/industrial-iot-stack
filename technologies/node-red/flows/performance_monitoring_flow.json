[
  {
    "id": "performance_monitor_1",
    "type": "tab",
    "label": "Performance Monitoring",
    "disabled": false,
    "info": "Real-time performance monitoring and bottleneck identification"
  },
  {
    "id": "performance_collector",
    "type": "function",
    "z": "performance_monitor_1",
    "name": "Performance Data Collector",
    "func": "// Collect comprehensive performance metrics\nconst metrics = flow.get('performanceMetrics') || {\n    system: {\n        cpu: [],\n        memory: [],\n        disk: [],\n        network: []\n    },\n    nodeRed: {\n        flows: {},\n        nodes: {},\n        messages: {\n            total: 0,\n            perSecond: 0,\n            errors: 0\n        }\n    },\n    equipment: {},\n    protocols: {\n        mqtt: { messages: 0, latency: [], errors: 0 },\n        opc: { calls: 0, latency: [], errors: 0 },\n        modbus: { transactions: 0, latency: [], errors: 0 }\n    },\n    bottlenecks: [],\n    alerts: []\n};\n\nfunction collectSystemMetrics() {\n    const timestamp = Date.now();\n    \n    // Mock system metrics - replace with actual system monitoring\n    const systemData = {\n        timestamp: timestamp,\n        cpu: {\n            usage: Math.random() * 100,\n            load1min: Math.random() * 4,\n            load5min: Math.random() * 4,\n            load15min: Math.random() * 4\n        },\n        memory: {\n            used: Math.random() * 8000,\n            total: 8192,\n            available: Math.random() * 2000,\n            cached: Math.random() * 1000\n        },\n        disk: {\n            used: Math.random() * 500,\n            total: 1000,\n            readIops: Math.random() * 100,\n            writeIops: Math.random() * 50\n        },\n        network: {\n            bytesIn: Math.random() * 10000,\n            bytesOut: Math.random() * 5000,\n            packetsIn: Math.random() * 1000,\n            packetsOut: Math.random() * 800\n        }\n    };\n    \n    // Store metrics with sliding window\n    ['cpu', 'memory', 'disk', 'network'].forEach(category => {\n        metrics.system[category].push(systemData[category]);\n        if (metrics.system[category].length > 1000) {\n            metrics.system[category].shift();\n        }\n    });\n    \n    return systemData;\n}\n\nfunction collectNodeRedMetrics() {\n    const timestamp = Date.now();\n    \n    // Get Node-RED runtime metrics\n    const runtime = {\n        timestamp: timestamp,\n        uptime: process.uptime(),\n        memory: process.memoryUsage(),\n        version: process.version,\n        activeFlows: Object.keys(metrics.nodeRed.flows).length\n    };\n    \n    // Calculate message throughput\n    const now = Date.now();\n    const oneSecondAgo = now - 1000;\n    \n    // Mock message counting - integrate with actual Node-RED metrics\n    const recentMessages = Math.floor(Math.random() * 1000);\n    metrics.nodeRed.messages.total += recentMessages;\n    metrics.nodeRed.messages.perSecond = recentMessages;\n    \n    return runtime;\n}\n\nfunction collectEquipmentMetrics() {\n    const equipmentRegistry = global.get('equipmentRegistry') || {};\n    const equipmentMetrics = {};\n    \n    Object.entries(equipmentRegistry).forEach(([id, equipment]) => {\n        equipmentMetrics[id] = {\n            status: equipment.status,\n            lastUpdate: equipment.lastUpdate,\n            messageCount: equipment.messageCount || 0,\n            errorCount: equipment.errorCount || 0,\n            latency: equipment.lastLatency || 0,\n            dataRate: calculateDataRate(equipment)\n        };\n    });\n    \n    return equipmentMetrics;\n}\n\nfunction calculateDataRate(equipment) {\n    if (!equipment.messageHistory) return 0;\n    \n    const now = Date.now();\n    const oneMinuteAgo = now - 60000;\n    \n    const recentMessages = equipment.messageHistory.filter(msg => \n        msg.timestamp > oneMinuteAgo\n    );\n    \n    return recentMessages.length; // Messages per minute\n}\n\nfunction collectProtocolMetrics() {\n    const protocolData = {\n        mqtt: {\n            timestamp: Date.now(),\n            connections: Math.floor(Math.random() * 50),\n            messagesPerSecond: Math.floor(Math.random() * 500),\n            averageLatency: Math.random() * 100,\n            qos0Messages: Math.floor(Math.random() * 300),\n            qos1Messages: Math.floor(Math.random() * 150),\n            qos2Messages: Math.floor(Math.random() * 50),\n            retained: Math.floor(Math.random() * 1000)\n        },\n        opc: {\n            timestamp: Date.now(),\n            activeSessions: Math.floor(Math.random() * 10),\n            subscriptions: Math.floor(Math.random() * 100),\n            monitoredItems: Math.floor(Math.random() * 500),\n            publishRequests: Math.floor(Math.random() * 200),\n            averageLatency: Math.random() * 200\n        },\n        modbus: {\n            timestamp: Date.now(),\n            activeConnections: Math.floor(Math.random() * 20),\n            transactionsPerSecond: Math.floor(Math.random() * 100),\n            averageLatency: Math.random() * 150,\n            timeouts: Math.floor(Math.random() * 5),\n            retries: Math.floor(Math.random() * 10)\n        }\n    };\n    \n    // Update protocol metrics\n    Object.entries(protocolData).forEach(([protocol, data]) => {\n        if (!metrics.protocols[protocol]) {\n            metrics.protocols[protocol] = { latency: [], errors: 0 };\n        }\n        \n        metrics.protocols[protocol].latency.push(data.averageLatency);\n        if (metrics.protocols[protocol].latency.length > 1000) {\n            metrics.protocols[protocol].latency.shift();\n        }\n    });\n    \n    return protocolData;\n}\n\nfunction identifyBottlenecks(systemData, nodeRedData, equipmentData, protocolData) {\n    const bottlenecks = [];\n    const timestamp = Date.now();\n    \n    // CPU bottleneck detection\n    if (systemData.cpu.usage > 80) {\n        bottlenecks.push({\n            type: 'cpu',\n            severity: systemData.cpu.usage > 95 ? 'critical' : 'warning',\n            value: systemData.cpu.usage,\n            message: `High CPU usage: ${systemData.cpu.usage.toFixed(1)}%`,\n            timestamp: timestamp,\n            recommendations: [\n                'Check for inefficient flows',\n                'Consider load balancing',\n                'Review function node complexity'\n            ]\n        });\n    }\n    \n    // Memory bottleneck detection\n    const memoryUsage = (systemData.memory.used / systemData.memory.total) * 100;\n    if (memoryUsage > 85) {\n        bottlenecks.push({\n            type: 'memory',\n            severity: memoryUsage > 95 ? 'critical' : 'warning',\n            value: memoryUsage,\n            message: `High memory usage: ${memoryUsage.toFixed(1)}%`,\n            timestamp: timestamp,\n            recommendations: [\n                'Check for memory leaks',\n                'Review context storage usage',\n                'Consider pagination for large datasets'\n            ]\n        });\n    }\n    \n    // Protocol latency bottlenecks\n    Object.entries(protocolData).forEach(([protocol, data]) => {\n        if (data.averageLatency > 500) {\n            bottlenecks.push({\n                type: 'protocol_latency',\n                protocol: protocol,\n                severity: data.averageLatency > 1000 ? 'critical' : 'warning',\n                value: data.averageLatency,\n                message: `High ${protocol.toUpperCase()} latency: ${data.averageLatency.toFixed(1)}ms`,\n                timestamp: timestamp,\n                recommendations: [\n                    'Check network connectivity',\n                    'Review server configuration',\n                    'Consider connection pooling'\n                ]\n            });\n        }\n    });\n    \n    // Equipment data rate bottlenecks\n    Object.entries(equipmentData).forEach(([id, equipment]) => {\n        if (equipment.dataRate > 1000) { // More than 1000 messages per minute\n            bottlenecks.push({\n                type: 'equipment_throughput',\n                equipment: id,\n                severity: equipment.dataRate > 2000 ? 'warning' : 'info',\n                value: equipment.dataRate,\n                message: `High data rate from ${id}: ${equipment.dataRate} msg/min`,\n                timestamp: timestamp,\n                recommendations: [\n                    'Consider data aggregation',\n                    'Implement sampling strategies',\n                    'Review polling intervals'\n                ]\n            });\n        }\n        \n        if (equipment.errorCount > 10) {\n            bottlenecks.push({\n                type: 'equipment_errors',\n                equipment: id,\n                severity: equipment.errorCount > 50 ? 'critical' : 'warning',\n                value: equipment.errorCount,\n                message: `High error count for ${id}: ${equipment.errorCount} errors`,\n                timestamp: timestamp,\n                recommendations: [\n                    'Check equipment connectivity',\n                    'Review configuration',\n                    'Implement error handling'\n                ]\n            });\n        }\n    });\n    \n    return bottlenecks;\n}\n\nif (msg.topic === 'collect_metrics') {\n    const systemData = collectSystemMetrics();\n    const nodeRedData = collectNodeRedMetrics();\n    const equipmentData = collectEquipmentMetrics();\n    const protocolData = collectProtocolMetrics();\n    \n    // Update metrics\n    metrics.equipment = equipmentData;\n    \n    // Identify bottlenecks\n    const bottlenecks = identifyBottlenecks(systemData, nodeRedData, equipmentData, protocolData);\n    metrics.bottlenecks = bottlenecks;\n    \n    // Store updated metrics\n    flow.set('performanceMetrics', metrics);\n    \n    return {\n        topic: 'metrics_collected',\n        payload: {\n            timestamp: Date.now(),\n            system: systemData,\n            nodeRed: nodeRedData,\n            equipment: equipmentData,\n            protocols: protocolData,\n            bottlenecks: bottlenecks\n        }\n    };\n} else if (msg.topic === 'get_metrics') {\n    return {\n        topic: 'current_metrics',\n        payload: metrics\n    };\n}\n\nreturn null;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 360,
    "y": 100,
    "wires": [["performance_analyzer"]]
  },
  {
    "id": "performance_analyzer",
    "type": "function",
    "z": "performance_monitor_1",
    "name": "Performance Analyzer",
    "func": "// Analyze performance trends and predict issues\nconst analysis = flow.get('performanceAnalysis') || {\n    trends: {},\n    predictions: {},\n    reports: [],\n    thresholds: {\n        cpu: { warning: 70, critical: 90 },\n        memory: { warning: 80, critical: 95 },\n        latency: { warning: 200, critical: 500 },\n        errorRate: { warning: 5, critical: 10 }\n    }\n};\n\nfunction analyzeTrends(metrics) {\n    const trends = {\n        timestamp: Date.now(),\n        system: {},\n        protocols: {},\n        equipment: {}\n    };\n    \n    // Analyze system trends\n    if (metrics.system.cpu.length > 10) {\n        trends.system.cpu = calculateTrend(metrics.system.cpu.slice(-10).map(c => c.usage));\n    }\n    \n    if (metrics.system.memory.length > 10) {\n        const memoryUsage = metrics.system.memory.slice(-10).map(m => (m.used / m.total) * 100);\n        trends.system.memory = calculateTrend(memoryUsage);\n    }\n    \n    // Analyze protocol trends\n    Object.entries(metrics.protocols).forEach(([protocol, data]) => {\n        if (data.latency.length > 10) {\n            trends.protocols[protocol] = {\n                latency: calculateTrend(data.latency.slice(-10))\n            };\n        }\n    });\n    \n    // Analyze equipment trends\n    Object.entries(metrics.equipment).forEach(([id, equipment]) => {\n        trends.equipment[id] = {\n            dataRate: equipment.dataRate,\n            errorRate: equipment.errorCount,\n            latency: equipment.latency\n        };\n    });\n    \n    return trends;\n}\n\nfunction calculateTrend(values) {\n    if (values.length < 2) return { direction: 'stable', slope: 0, confidence: 0 };\n    \n    // Simple linear regression\n    const n = values.length;\n    const x = Array.from({ length: n }, (_, i) => i);\n    const y = values;\n    \n    const sumX = x.reduce((a, b) => a + b, 0);\n    const sumY = y.reduce((a, b) => a + b, 0);\n    const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);\n    const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);\n    \n    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);\n    const intercept = (sumY - slope * sumX) / n;\n    \n    // Calculate R-squared for confidence\n    const yMean = sumY / n;\n    const ssTotal = y.reduce((sum, yi) => sum + Math.pow(yi - yMean, 2), 0);\n    const ssRes = y.reduce((sum, yi, i) => {\n        const predicted = slope * x[i] + intercept;\n        return sum + Math.pow(yi - predicted, 2);\n    }, 0);\n    \n    const rSquared = 1 - (ssRes / ssTotal);\n    \n    let direction = 'stable';\n    if (Math.abs(slope) > 0.1) {\n        direction = slope > 0 ? 'increasing' : 'decreasing';\n    }\n    \n    return {\n        direction: direction,\n        slope: slope,\n        confidence: rSquared,\n        predicted: slope * (n + 1) + intercept // Next value prediction\n    };\n}\n\nfunction predictIssues(trends, currentMetrics) {\n    const predictions = {\n        timestamp: Date.now(),\n        alerts: [],\n        recommendations: []\n    };\n    \n    // CPU prediction\n    if (trends.system.cpu && trends.system.cpu.direction === 'increasing') {\n        const timeToThreshold = calculateTimeToThreshold(\n            trends.system.cpu.predicted,\n            trends.system.cpu.slope,\n            analysis.thresholds.cpu.warning\n        );\n        \n        if (timeToThreshold < 3600000) { // Less than 1 hour\n            predictions.alerts.push({\n                type: 'cpu_prediction',\n                severity: 'warning',\n                message: `CPU usage trending upward. Expected to reach ${analysis.thresholds.cpu.warning}% in ${Math.round(timeToThreshold / 60000)} minutes`,\n                timeToThreshold: timeToThreshold,\n                confidence: trends.system.cpu.confidence\n            });\n            \n            predictions.recommendations.push({\n                area: 'cpu',\n                action: 'Scale horizontally or optimize flows',\n                priority: 'medium'\n            });\n        }\n    }\n    \n    // Memory prediction\n    if (trends.system.memory && trends.system.memory.direction === 'increasing') {\n        const timeToThreshold = calculateTimeToThreshold(\n            trends.system.memory.predicted,\n            trends.system.memory.slope,\n            analysis.thresholds.memory.warning\n        );\n        \n        if (timeToThreshold < 7200000) { // Less than 2 hours\n            predictions.alerts.push({\n                type: 'memory_prediction',\n                severity: 'warning',\n                message: `Memory usage trending upward. Expected to reach ${analysis.thresholds.memory.warning}% in ${Math.round(timeToThreshold / 60000)} minutes`,\n                timeToThreshold: timeToThreshold,\n                confidence: trends.system.memory.confidence\n            });\n            \n            predictions.recommendations.push({\n                area: 'memory',\n                action: 'Review context usage and implement cleanup',\n                priority: 'medium'\n            });\n        }\n    }\n    \n    // Protocol latency predictions\n    Object.entries(trends.protocols).forEach(([protocol, data]) => {\n        if (data.latency && data.latency.direction === 'increasing') {\n            const timeToThreshold = calculateTimeToThreshold(\n                data.latency.predicted,\n                data.latency.slope,\n                analysis.thresholds.latency.warning\n            );\n            \n            if (timeToThreshold < 1800000) { // Less than 30 minutes\n                predictions.alerts.push({\n                    type: 'latency_prediction',\n                    protocol: protocol,\n                    severity: 'warning',\n                    message: `${protocol.toUpperCase()} latency trending upward. Expected to reach ${analysis.thresholds.latency.warning}ms in ${Math.round(timeToThreshold / 60000)} minutes`,\n                    timeToThreshold: timeToThreshold,\n                    confidence: data.latency.confidence\n                });\n                \n                predictions.recommendations.push({\n                    area: 'protocols',\n                    protocol: protocol,\n                    action: 'Check network and server performance',\n                    priority: 'high'\n                });\n            }\n        }\n    });\n    \n    return predictions;\n}\n\nfunction calculateTimeToThreshold(current, slope, threshold) {\n    if (slope <= 0) return Infinity;\n    \n    const diff = threshold - current;\n    if (diff <= 0) return 0;\n    \n    // Assuming measurements every minute\n    const minutesToThreshold = diff / slope;\n    return minutesToThreshold * 60000; // Convert to milliseconds\n}\n\nfunction generatePerformanceReport(metrics, trends, predictions) {\n    const report = {\n        id: `perf_report_${Date.now()}`,\n        timestamp: Date.now(),\n        summary: {\n            overall_health: 'good',\n            active_bottlenecks: metrics.bottlenecks.length,\n            predicted_issues: predictions.alerts.length,\n            monitoring_duration: getMonitoringDuration()\n        },\n        current_state: {\n            system: getCurrentSystemState(metrics),\n            protocols: getCurrentProtocolState(metrics),\n            equipment: getCurrentEquipmentState(metrics)\n        },\n        trends: trends,\n        predictions: predictions,\n        recommendations: generateRecommendations(metrics, trends, predictions)\n    };\n    \n    // Determine overall health\n    let criticalIssues = 0;\n    let warningIssues = 0;\n    \n    metrics.bottlenecks.forEach(b => {\n        if (b.severity === 'critical') criticalIssues++;\n        else if (b.severity === 'warning') warningIssues++;\n    });\n    \n    predictions.alerts.forEach(a => {\n        if (a.severity === 'critical') criticalIssues++;\n        else if (a.severity === 'warning') warningIssues++;\n    });\n    \n    if (criticalIssues > 0) {\n        report.summary.overall_health = 'critical';\n    } else if (warningIssues > 0) {\n        report.summary.overall_health = 'warning';\n    }\n    \n    return report;\n}\n\nfunction getCurrentSystemState(metrics) {\n    const latest = {\n        cpu: metrics.system.cpu[metrics.system.cpu.length - 1],\n        memory: metrics.system.memory[metrics.system.memory.length - 1],\n        disk: metrics.system.disk[metrics.system.disk.length - 1],\n        network: metrics.system.network[metrics.system.network.length - 1]\n    };\n    \n    return {\n        cpu_usage: latest.cpu ? latest.cpu.usage : 0,\n        memory_usage: latest.memory ? (latest.memory.used / latest.memory.total) * 100 : 0,\n        disk_usage: latest.disk ? (latest.disk.used / latest.disk.total) * 100 : 0,\n        network_utilization: latest.network ? latest.network.bytesIn + latest.network.bytesOut : 0\n    };\n}\n\nfunction getCurrentProtocolState(metrics) {\n    const state = {};\n    \n    Object.entries(metrics.protocols).forEach(([protocol, data]) => {\n        const latencies = data.latency;\n        state[protocol] = {\n            avg_latency: latencies.length > 0 ? latencies.reduce((a, b) => a + b, 0) / latencies.length : 0,\n            max_latency: latencies.length > 0 ? Math.max(...latencies) : 0,\n            error_count: data.errors || 0\n        };\n    });\n    \n    return state;\n}\n\nfunction getCurrentEquipmentState(metrics) {\n    const state = {\n        total_devices: Object.keys(metrics.equipment).length,\n        healthy: 0,\n        warning: 0,\n        error: 0,\n        total_messages: 0\n    };\n    \n    Object.values(metrics.equipment).forEach(equipment => {\n        state.total_messages += equipment.messageCount || 0;\n        \n        if (equipment.errorCount > 10) {\n            state.error++;\n        } else if (equipment.errorCount > 5 || equipment.latency > 200) {\n            state.warning++;\n        } else {\n            state.healthy++;\n        }\n    });\n    \n    return state;\n}\n\nfunction generateRecommendations(metrics, trends, predictions) {\n    const recommendations = [];\n    \n    // Add prediction-based recommendations\n    recommendations.push(...predictions.recommendations);\n    \n    // Add bottleneck-based recommendations\n    metrics.bottlenecks.forEach(bottleneck => {\n        recommendations.push(...bottleneck.recommendations.map(rec => ({\n            area: bottleneck.type,\n            action: rec,\n            priority: bottleneck.severity === 'critical' ? 'high' : 'medium',\n            source: 'bottleneck_analysis'\n        })));\n    });\n    \n    // Add general optimization recommendations\n    const equipmentCount = Object.keys(metrics.equipment).length;\n    if (equipmentCount > 100) {\n        recommendations.push({\n            area: 'scalability',\n            action: 'Consider implementing equipment grouping or hierarchical monitoring',\n            priority: 'low',\n            source: 'scalability_analysis'\n        });\n    }\n    \n    return recommendations;\n}\n\nfunction getMonitoringDuration() {\n    const startTime = flow.get('monitoringStartTime') || Date.now();\n    return Date.now() - startTime;\n}\n\nif (msg.topic === 'metrics_collected') {\n    const metrics = msg.payload;\n    \n    // Analyze trends\n    const currentMetrics = flow.get('performanceMetrics') || {};\n    const trends = analyzeTrends(currentMetrics);\n    \n    // Predict issues\n    const predictions = predictIssues(trends, metrics);\n    \n    // Generate report\n    const report = generatePerformanceReport(currentMetrics, trends, predictions);\n    \n    // Store analysis\n    analysis.trends = trends;\n    analysis.predictions = predictions;\n    analysis.reports.push(report);\n    \n    // Keep only last 100 reports\n    if (analysis.reports.length > 100) {\n        analysis.reports.shift();\n    }\n    \n    flow.set('performanceAnalysis', analysis);\n    \n    return [\n        {\n            topic: 'performance_analysis',\n            payload: {\n                trends: trends,\n                predictions: predictions,\n                report: report\n            }\n        },\n        {\n            topic: 'dashboard_update',\n            payload: {\n                type: 'performance',\n                data: report\n            }\n        }\n    ];\n}\n\nreturn null;",
    "outputs": 2,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 570,
    "y": 100,
    "wires": [["performance_alerting"], ["performance_dashboard"]]
  },
  {
    "id": "performance_dashboard",
    "type": "ui_template",
    "z": "performance_monitor_1",
    "group": "performance_group",
    "name": "Performance Dashboard",
    "order": 1,
    "width": 24,
    "height": 24,
    "format": "<div id=\"performance-dashboard\">\n    <style>\n        #performance-dashboard {\n            font-family: Arial, sans-serif;\n            padding: 10px;\n            background: #1a1a1a;\n            color: #e0e0e0;\n            min-height: 100vh;\n        }\n        \n        .dashboard-header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            margin-bottom: 20px;\n            padding: 15px;\n            background: #2d2d2d;\n            border-radius: 8px;\n            border-left: 4px solid #4a9eff;\n        }\n        \n        .health-indicator {\n            display: flex;\n            align-items: center;\n            font-size: 18px;\n            font-weight: bold;\n        }\n        \n        .health-good { color: #4caf50; }\n        .health-warning { color: #ff9800; }\n        .health-critical { color: #f44336; }\n        \n        .metrics-grid {\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n            gap: 15px;\n            margin-bottom: 20px;\n        }\n        \n        .metric-card {\n            background: #2d2d2d;\n            border-radius: 8px;\n            padding: 20px;\n            border: 1px solid #3d3d3d;\n            transition: transform 0.2s;\n        }\n        \n        .metric-card:hover {\n            transform: translateY(-2px);\n            box-shadow: 0 4px 12px rgba(0,0,0,0.3);\n        }\n        \n        .metric-card h3 {\n            margin: 0 0 15px 0;\n            color: #4a9eff;\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n        }\n        \n        .metric-value {\n            font-size: 32px;\n            font-weight: bold;\n            text-align: center;\n            margin: 15px 0;\n        }\n        \n        .metric-trend {\n            font-size: 14px;\n            text-align: center;\n        }\n        \n        .trend-up { color: #f44336; }\n        .trend-down { color: #4caf50; }\n        .trend-stable { color: #ff9800; }\n        \n        .chart-container {\n            height: 200px;\n            margin: 15px 0;\n            background: #1e1e1e;\n            border-radius: 4px;\n            padding: 10px;\n            position: relative;\n        }\n        \n        .chart-title {\n            font-size: 12px;\n            color: #a0a0a0;\n            margin-bottom: 10px;\n        }\n        \n        .bottlenecks-section {\n            grid-column: 1 / -1;\n            background: #2d2d2d;\n            border-radius: 8px;\n            padding: 20px;\n            margin-bottom: 20px;\n        }\n        \n        .bottleneck-item {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            padding: 12px;\n            margin: 8px 0;\n            border-radius: 6px;\n            border-left: 4px solid;\n        }\n        \n        .bottleneck-critical {\n            background: rgba(244, 67, 54, 0.1);\n            border-left-color: #f44336;\n        }\n        \n        .bottleneck-warning {\n            background: rgba(255, 152, 0, 0.1);\n            border-left-color: #ff9800;\n        }\n        \n        .bottleneck-info {\n            background: rgba(74, 158, 255, 0.1);\n            border-left-color: #4a9eff;\n        }\n        \n        .predictions-section {\n            grid-column: 1 / -1;\n            background: #2d2d2d;\n            border-radius: 8px;\n            padding: 20px;\n        }\n        \n        .prediction-item {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            padding: 12px;\n            margin: 8px 0;\n            border-radius: 6px;\n            background: rgba(255, 193, 7, 0.1);\n            border-left: 4px solid #ffc107;\n        }\n        \n        .time-to-threshold {\n            font-weight: bold;\n            color: #ffc107;\n        }\n        \n        .recommendations {\n            display: grid;\n            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n            gap: 10px;\n            margin-top: 15px;\n        }\n        \n        .recommendation {\n            background: #1e1e1e;\n            padding: 12px;\n            border-radius: 6px;\n            border-left: 4px solid #4a9eff;\n        }\n        \n        .priority-high { border-left-color: #f44336; }\n        .priority-medium { border-left-color: #ff9800; }\n        .priority-low { border-left-color: #4caf50; }\n        \n        .equipment-status {\n            display: grid;\n            grid-template-columns: repeat(4, 1fr);\n            gap: 10px;\n            margin-top: 15px;\n        }\n        \n        .equipment-stat {\n            text-align: center;\n            padding: 15px;\n            background: #1e1e1e;\n            border-radius: 6px;\n        }\n        \n        .equipment-stat .count {\n            font-size: 24px;\n            font-weight: bold;\n            margin-bottom: 5px;\n        }\n        \n        .equipment-stat .label {\n            font-size: 12px;\n            color: #a0a0a0;\n        }\n        \n        .control-panel {\n            display: flex;\n            gap: 10px;\n            align-items: center;\n        }\n        \n        .control-button {\n            padding: 8px 16px;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            background: #4a9eff;\n            color: white;\n            transition: background 0.3s;\n        }\n        \n        .control-button:hover {\n            background: #357abd;\n        }\n        \n        .control-button.danger {\n            background: #f44336;\n        }\n        \n        .control-button.danger:hover {\n            background: #d32f2f;\n        }\n        \n        .refresh-indicator {\n            display: inline-block;\n            margin-left: 10px;\n            color: #4caf50;\n            font-size: 12px;\n        }\n        \n        .gauge {\n            width: 120px;\n            height: 120px;\n            margin: 0 auto;\n            position: relative;\n        }\n        \n        .gauge-background {\n            width: 100%;\n            height: 100%;\n            border-radius: 50%;\n            background: conic-gradient(from 0deg, #1e1e1e 0deg, #3d3d3d 360deg);\n            position: relative;\n        }\n        \n        .gauge-fill {\n            position: absolute;\n            top: 10px;\n            left: 10px;\n            width: calc(100% - 20px);\n            height: calc(100% - 20px);\n            border-radius: 50%;\n            background: #1e1e1e;\n        }\n        \n        .gauge-text {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            font-size: 18px;\n            font-weight: bold;\n        }\n    </style>\n    \n    <div class=\"dashboard-header\">\n        <div>\n            <h2>Performance Monitoring</h2>\n            <div class=\"health-indicator\" id=\"health-indicator\">\n                <span id=\"health-status\">System Health: Good</span>\n            </div>\n        </div>\n        <div class=\"control-panel\">\n            <span id=\"last-update\" class=\"refresh-indicator\">Last Update: Never</span>\n            <button class=\"control-button\" onclick=\"refreshMetrics()\">Refresh</button>\n            <button class=\"control-button\" onclick=\"exportReport()\">Export Report</button>\n            <button class=\"control-button danger\" onclick=\"clearHistory()\">Clear History</button>\n        </div>\n    </div>\n    \n    <div class=\"metrics-grid\">\n        <!-- System Metrics -->\n        <div class=\"metric-card\">\n            <h3>CPU Usage <span id=\"cpu-trend\" class=\"metric-trend\">●</span></h3>\n            <div class=\"gauge\">\n                <div class=\"gauge-background\">\n                    <div class=\"gauge-fill\"></div>\n                    <div class=\"gauge-text\" id=\"cpu-value\">0%</div>\n                </div>\n            </div>\n            <div class=\"chart-container\">\n                <div class=\"chart-title\">CPU Usage Over Time</div>\n                <div id=\"cpu-chart\"></div>\n            </div>\n        </div>\n        \n        <div class=\"metric-card\">\n            <h3>Memory Usage <span id=\"memory-trend\" class=\"metric-trend\">●</span></h3>\n            <div class=\"gauge\">\n                <div class=\"gauge-background\">\n                    <div class=\"gauge-fill\"></div>\n                    <div class=\"gauge-text\" id=\"memory-value\">0%</div>\n                </div>\n            </div>\n            <div class=\"chart-container\">\n                <div class=\"chart-title\">Memory Usage Over Time</div>\n                <div id=\"memory-chart\"></div>\n            </div>\n        </div>\n        \n        <div class=\"metric-card\">\n            <h3>Network I/O <span id=\"network-trend\" class=\"metric-trend\">●</span></h3>\n            <div class=\"metric-value\" id=\"network-value\">0 KB/s</div>\n            <div class=\"chart-container\">\n                <div class=\"chart-title\">Network Throughput</div>\n                <div id=\"network-chart\"></div>\n            </div>\n        </div>\n        \n        <div class=\"metric-card\">\n            <h3>Protocol Latency</h3>\n            <div id=\"protocol-metrics\">\n                <div style=\"display: flex; justify-content: space-between; margin: 5px 0;\">\n                    <span>MQTT:</span><span id=\"mqtt-latency\">0ms</span>\n                </div>\n                <div style=\"display: flex; justify-content: space-between; margin: 5px 0;\">\n                    <span>OPC UA:</span><span id=\"opc-latency\">0ms</span>\n                </div>\n                <div style=\"display: flex; justify-content: space-between; margin: 5px 0;\">\n                    <span>Modbus:</span><span id=\"modbus-latency\">0ms</span>\n                </div>\n            </div>\n            <div class=\"chart-container\">\n                <div class=\"chart-title\">Average Protocol Latency</div>\n                <div id=\"protocol-chart\"></div>\n            </div>\n        </div>\n        \n        <!-- Equipment Status -->\n        <div class=\"metric-card\">\n            <h3>Equipment Status</h3>\n            <div class=\"equipment-status\">\n                <div class=\"equipment-stat\">\n                    <div class=\"count status-good\" id=\"healthy-count\">0</div>\n                    <div class=\"label\">Healthy</div>\n                </div>\n                <div class=\"equipment-stat\">\n                    <div class=\"count status-warning\" id=\"warning-count\">0</div>\n                    <div class=\"label\">Warning</div>\n                </div>\n                <div class=\"equipment-stat\">\n                    <div class=\"count status-error\" id=\"error-count\">0</div>\n                    <div class=\"label\">Error</div>\n                </div>\n                <div class=\"equipment-stat\">\n                    <div class=\"count\" id=\"total-count\">0</div>\n                    <div class=\"label\">Total</div>\n                </div>\n            </div>\n            <div style=\"margin-top: 15px; text-align: center;\">\n                <strong>Messages/Hour: <span id=\"message-rate\">0</span></strong>\n            </div>\n        </div>\n        \n        <!-- Node-RED Performance -->\n        <div class=\"metric-card\">\n            <h3>Node-RED Performance</h3>\n            <div style=\"display: flex; justify-content: space-between; margin: 10px 0;\">\n                <span>Uptime:</span><span id=\"node-uptime\">0h 0m</span>\n            </div>\n            <div style=\"display: flex; justify-content: space-between; margin: 10px 0;\">\n                <span>Memory:</span><span id=\"node-memory\">0 MB</span>\n            </div>\n            <div style=\"display: flex; justify-content: space-between; margin: 10px 0;\">\n                <span>Messages/sec:</span><span id=\"node-messages\">0</span>\n            </div>\n            <div style=\"display: flex; justify-content: space-between; margin: 10px 0;\">\n                <span>Active Flows:</span><span id=\"node-flows\">0</span>\n            </div>\n        </div>\n    </div>\n    \n    <!-- Bottlenecks Section -->\n    <div class=\"bottlenecks-section\">\n        <h3>Current Bottlenecks</h3>\n        <div id=\"bottlenecks-list\">\n            <p style=\"text-align: center; color: #666;\">No bottlenecks detected</p>\n        </div>\n    </div>\n    \n    <!-- Predictions Section -->\n    <div class=\"predictions-section\">\n        <h3>Performance Predictions</h3>\n        <div id=\"predictions-list\">\n            <p style=\"text-align: center; color: #666;\">No predictions available</p>\n        </div>\n        \n        <h4 style=\"margin-top: 20px;\">Recommendations</h4>\n        <div class=\"recommendations\" id=\"recommendations-list\">\n            <p style=\"text-align: center; color: #666; grid-column: 1 / -1;\">No recommendations</p>\n        </div>\n    </div>\n</div>\n\n<script>\n(function(scope) {\n    let performanceData = {};\n    \n    scope.$watch('msg', function(msg) {\n        if (!msg || !msg.payload) return;\n        \n        if (msg.topic === 'dashboard_update' && msg.payload.type === 'performance') {\n            updateDashboard(msg.payload.data);\n        } else if (msg.topic === 'metrics_collected') {\n            updateRealTimeMetrics(msg.payload);\n        }\n        \n        updateLastUpdate();\n    });\n    \n    function updateDashboard(report) {\n        performanceData = report;\n        \n        // Update health indicator\n        const healthElement = document.getElementById('health-status');\n        const healthIndicator = document.getElementById('health-indicator');\n        \n        healthElement.textContent = `System Health: ${report.summary.overall_health.charAt(0).toUpperCase() + report.summary.overall_health.slice(1)}`;\n        healthIndicator.className = 'health-indicator health-' + report.summary.overall_health;\n        \n        // Update system metrics\n        updateSystemMetrics(report.current_state.system);\n        \n        // Update protocol metrics\n        updateProtocolMetrics(report.current_state.protocols);\n        \n        // Update equipment status\n        updateEquipmentStatus(report.current_state.equipment);\n        \n        // Update bottlenecks\n        updateBottlenecks(report.bottlenecks || []);\n        \n        // Update predictions\n        updatePredictions(report.predictions);\n        \n        // Update trends\n        updateTrends(report.trends);\n    }\n    \n    function updateSystemMetrics(system) {\n        // CPU\n        const cpuValue = Math.round(system.cpu_usage || 0);\n        document.getElementById('cpu-value').textContent = cpuValue + '%';\n        updateGauge('cpu', cpuValue);\n        \n        // Memory\n        const memoryValue = Math.round(system.memory_usage || 0);\n        document.getElementById('memory-value').textContent = memoryValue + '%';\n        updateGauge('memory', memoryValue);\n        \n        // Network\n        const networkValue = formatBytes(system.network_utilization || 0);\n        document.getElementById('network-value').textContent = networkValue + '/s';\n    }\n    \n    function updateProtocolMetrics(protocols) {\n        Object.entries(protocols).forEach(([protocol, data]) => {\n            const latencyElement = document.getElementById(protocol + '-latency');\n            if (latencyElement) {\n                latencyElement.textContent = Math.round(data.avg_latency || 0) + 'ms';\n                \n                // Color code based on latency\n                if (data.avg_latency > 500) {\n                    latencyElement.style.color = '#f44336';\n                } else if (data.avg_latency > 200) {\n                    latencyElement.style.color = '#ff9800';\n                } else {\n                    latencyElement.style.color = '#4caf50';\n                }\n            }\n        });\n    }\n    \n    function updateEquipmentStatus(equipment) {\n        document.getElementById('healthy-count').textContent = equipment.healthy || 0;\n        document.getElementById('warning-count').textContent = equipment.warning || 0;\n        document.getElementById('error-count').textContent = equipment.error || 0;\n        document.getElementById('total-count').textContent = equipment.total_devices || 0;\n        document.getElementById('message-rate').textContent = formatNumber(equipment.total_messages || 0);\n    }\n    \n    function updateBottlenecks(bottlenecks) {\n        const container = document.getElementById('bottlenecks-list');\n        \n        if (bottlenecks.length === 0) {\n            container.innerHTML = '<p style=\"text-align: center; color: #666;\">No bottlenecks detected</p>';\n            return;\n        }\n        \n        container.innerHTML = '';\n        \n        bottlenecks.forEach(bottleneck => {\n            const item = document.createElement('div');\n            item.className = 'bottleneck-item bottleneck-' + bottleneck.severity;\n            item.innerHTML = `\n                <div>\n                    <strong>${bottleneck.type.replace('_', ' ').toUpperCase()}</strong>\n                    <div>${bottleneck.message}</div>\n                    <small>${new Date(bottleneck.timestamp).toLocaleTimeString()}</small>\n                </div>\n                <div style=\"text-align: right;\">\n                    <div style=\"font-size: 18px; font-weight: bold;\">${bottleneck.value.toFixed(1)}</div>\n                    <div style=\"font-size: 12px; color: #a0a0a0;\">${bottleneck.severity}</div>\n                </div>\n            `;\n            container.appendChild(item);\n        });\n    }\n    \n    function updatePredictions(predictions) {\n        const container = document.getElementById('predictions-list');\n        const recommendationsContainer = document.getElementById('recommendations-list');\n        \n        // Update predictions\n        if (!predictions || predictions.alerts.length === 0) {\n            container.innerHTML = '<p style=\"text-align: center; color: #666;\">No predictions available</p>';\n        } else {\n            container.innerHTML = '';\n            \n            predictions.alerts.forEach(alert => {\n                const item = document.createElement('div');\n                item.className = 'prediction-item';\n                item.innerHTML = `\n                    <div>\n                        <strong>${alert.type.replace('_', ' ').toUpperCase()}</strong>\n                        <div>${alert.message}</div>\n                        <small>Confidence: ${(alert.confidence * 100).toFixed(1)}%</small>\n                    </div>\n                    <div class=\"time-to-threshold\">\n                        ${formatDuration(alert.timeToThreshold)}\n                    </div>\n                `;\n                container.appendChild(item);\n            });\n        }\n        \n        // Update recommendations\n        if (!predictions || predictions.recommendations.length === 0) {\n            recommendationsContainer.innerHTML = '<p style=\"text-align: center; color: #666; grid-column: 1 / -1;\">No recommendations</p>';\n        } else {\n            recommendationsContainer.innerHTML = '';\n            \n            predictions.recommendations.forEach(rec => {\n                const item = document.createElement('div');\n                item.className = 'recommendation priority-' + rec.priority;\n                item.innerHTML = `\n                    <div style=\"font-weight: bold; margin-bottom: 5px;\">${rec.area.toUpperCase()}</div>\n                    <div>${rec.action}</div>\n                    <div style=\"font-size: 12px; color: #a0a0a0; margin-top: 5px;\">Priority: ${rec.priority}</div>\n                `;\n                recommendationsContainer.appendChild(item);\n            });\n        }\n    }\n    \n    function updateTrends(trends) {\n        if (!trends || !trends.system) return;\n        \n        // Update trend indicators\n        updateTrendIndicator('cpu-trend', trends.system.cpu);\n        updateTrendIndicator('memory-trend', trends.system.memory);\n    }\n    \n    function updateTrendIndicator(elementId, trend) {\n        const element = document.getElementById(elementId);\n        if (!element || !trend) return;\n        \n        let className = 'metric-trend trend-stable';\n        let symbol = '●';\n        \n        if (trend.direction === 'increasing') {\n            className = 'metric-trend trend-up';\n            symbol = '▲';\n        } else if (trend.direction === 'decreasing') {\n            className = 'metric-trend trend-down';\n            symbol = '▼';\n        }\n        \n        element.className = className;\n        element.textContent = symbol;\n    }\n    \n    function updateGauge(type, value) {\n        // Simple gauge update - in a real implementation, use a charting library\n        const gauge = document.querySelector(`#${type}-value`).parentElement;\n        const background = gauge.querySelector('.gauge-background');\n        \n        let color = '#4caf50';\n        if (value > 80) color = '#f44336';\n        else if (value > 60) color = '#ff9800';\n        \n        const angle = (value / 100) * 360;\n        background.style.background = `conic-gradient(from 0deg, ${color} 0deg, ${color} ${angle}deg, #3d3d3d ${angle}deg, #3d3d3d 360deg)`;\n    }\n    \n    function updateRealTimeMetrics(metrics) {\n        // Update Node-RED specific metrics\n        if (metrics.nodeRed) {\n            const uptime = formatDuration(metrics.nodeRed.uptime * 1000);\n            const memory = formatBytes(metrics.nodeRed.memory.heapUsed);\n            \n            document.getElementById('node-uptime').textContent = uptime;\n            document.getElementById('node-memory').textContent = memory;\n            document.getElementById('node-messages').textContent = metrics.nodeRed.messages.perSecond;\n            document.getElementById('node-flows').textContent = metrics.nodeRed.activeFlows;\n        }\n    }\n    \n    function formatBytes(bytes) {\n        if (bytes === 0) return '0 B';\n        const k = 1024;\n        const sizes = ['B', 'KB', 'MB', 'GB'];\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];\n    }\n    \n    function formatNumber(num) {\n        if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';\n        if (num >= 1000) return (num / 1000).toFixed(1) + 'K';\n        return num.toString();\n    }\n    \n    function formatDuration(ms) {\n        const seconds = Math.floor(ms / 1000);\n        const minutes = Math.floor(seconds / 60);\n        const hours = Math.floor(minutes / 60);\n        const days = Math.floor(hours / 24);\n        \n        if (days > 0) return `${days}d ${hours % 24}h`;\n        if (hours > 0) return `${hours}h ${minutes % 60}m`;\n        if (minutes > 0) return `${minutes}m ${seconds % 60}s`;\n        return `${seconds}s`;\n    }\n    \n    function updateLastUpdate() {\n        document.getElementById('last-update').textContent = 'Last Update: ' + new Date().toLocaleTimeString();\n    }\n    \n    // Global functions for controls\n    window.refreshMetrics = function() {\n        scope.send({ topic: 'collect_metrics', payload: {} });\n    };\n    \n    window.exportReport = function() {\n        if (performanceData) {\n            const report = JSON.stringify(performanceData, null, 2);\n            const blob = new Blob([report], { type: 'application/json' });\n            const url = URL.createObjectURL(blob);\n            const a = document.createElement('a');\n            a.href = url;\n            a.download = `performance_report_${new Date().getTime()}.json`;\n            a.click();\n            URL.revokeObjectURL(url);\n        }\n    };\n    \n    window.clearHistory = function() {\n        if (confirm('Clear all performance history?')) {\n            scope.send({ topic: 'clear_history', payload: {} });\n        }\n    };\n    \n    // Auto-refresh every 30 seconds\n    setInterval(function() {\n        scope.send({ topic: 'collect_metrics', payload: {} });\n    }, 30000);\n    \n    // Initial load\n    scope.send({ topic: 'collect_metrics', payload: {} });\n})(scope);\n</script>",
    "storeOutMessages": true,
    "fwdInMessages": true,
    "resendOnRefresh": true,
    "templateScope": "local",
    "x": 820,
    "y": 200,
    "wires": [[]]
  },
  {
    "id": "performance_alerting",
    "type": "function",
    "z": "performance_monitor_1",
    "name": "Performance Alerting",
    "func": "// Generate alerts based on performance analysis\nconst alerts = flow.get('performanceAlerts') || {\n    active: {},\n    history: [],\n    rules: {\n        cpu_critical: { threshold: 90, duration: 300000 }, // 5 minutes\n        memory_critical: { threshold: 95, duration: 600000 }, // 10 minutes\n        latency_critical: { threshold: 1000, duration: 120000 }, // 2 minutes\n        prediction_warning: { confidence: 0.7, timeToThreshold: 1800000 } // 30 minutes\n    }\n};\n\nfunction createAlert(type, data) {\n    const alert = {\n        id: `perf_alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        type: type,\n        timestamp: Date.now(),\n        severity: determineSeverity(type, data),\n        message: generateAlertMessage(type, data),\n        data: data,\n        status: 'active',\n        acknowledged: false,\n        escalated: false\n    };\n    \n    return alert;\n}\n\nfunction determineSeverity(type, data) {\n    switch (type) {\n        case 'system_critical':\n            return 'critical';\n        case 'bottleneck_detected':\n            return data.severity || 'warning';\n        case 'prediction_alert':\n            return data.severity || 'warning';\n        case 'equipment_degradation':\n            return data.errorRate > 20 ? 'critical' : 'warning';\n        default:\n            return 'info';\n    }\n}\n\nfunction generateAlertMessage(type, data) {\n    switch (type) {\n        case 'system_critical':\n            return `System critical: ${data.metric} at ${data.value.toFixed(1)}${data.unit}`;\n        case 'bottleneck_detected':\n            return `Bottleneck detected: ${data.message}`;\n        case 'prediction_alert':\n            return `Performance prediction: ${data.message}`;\n        case 'equipment_degradation':\n            return `Equipment ${data.equipmentId} showing degraded performance`;\n        default:\n            return `Performance alert: ${JSON.stringify(data)}`;\n    }\n}\n\nfunction processBottlenecks(bottlenecks) {\n    const newAlerts = [];\n    \n    bottlenecks.forEach(bottleneck => {\n        const alertKey = `${bottleneck.type}_${bottleneck.equipment || 'system'}`;\n        \n        // Check if this bottleneck already has an active alert\n        if (!alerts.active[alertKey] || \n            alerts.active[alertKey].status !== 'active') {\n            \n            const alert = createAlert('bottleneck_detected', bottleneck);\n            alerts.active[alertKey] = alert;\n            newAlerts.push(alert);\n        } else {\n            // Update existing alert\n            alerts.active[alertKey].data = bottleneck;\n            alerts.active[alertKey].timestamp = Date.now();\n        }\n    });\n    \n    return newAlerts;\n}\n\nfunction processPredictions(predictions) {\n    const newAlerts = [];\n    \n    if (predictions && predictions.alerts) {\n        predictions.alerts.forEach(prediction => {\n            const alertKey = `prediction_${prediction.type}`;\n            \n            // Only create alert if confidence is high enough and time is short enough\n            if (prediction.confidence >= alerts.rules.prediction_warning.confidence &&\n                prediction.timeToThreshold <= alerts.rules.prediction_warning.timeToThreshold) {\n                \n                if (!alerts.active[alertKey] || \n                    alerts.active[alertKey].status !== 'active') {\n                    \n                    const alert = createAlert('prediction_alert', prediction);\n                    alerts.active[alertKey] = alert;\n                    newAlerts.push(alert);\n                }\n            }\n        });\n    }\n    \n    return newAlerts;\n}\n\nfunction processSystemMetrics(system) {\n    const newAlerts = [];\n    \n    // Check CPU\n    if (system.cpu_usage >= alerts.rules.cpu_critical.threshold) {\n        const alertKey = 'cpu_critical';\n        if (!alerts.active[alertKey]) {\n            const alert = createAlert('system_critical', {\n                metric: 'CPU usage',\n                value: system.cpu_usage,\n                unit: '%',\n                threshold: alerts.rules.cpu_critical.threshold\n            });\n            alerts.active[alertKey] = alert;\n            newAlerts.push(alert);\n        }\n    }\n    \n    // Check Memory\n    if (system.memory_usage >= alerts.rules.memory_critical.threshold) {\n        const alertKey = 'memory_critical';\n        if (!alerts.active[alertKey]) {\n            const alert = createAlert('system_critical', {\n                metric: 'Memory usage',\n                value: system.memory_usage,\n                unit: '%',\n                threshold: alerts.rules.memory_critical.threshold\n            });\n            alerts.active[alertKey] = alert;\n            newAlerts.push(alert);\n        }\n    }\n    \n    return newAlerts;\n}\n\nfunction processProtocolMetrics(protocols) {\n    const newAlerts = [];\n    \n    Object.entries(protocols).forEach(([protocol, data]) => {\n        if (data.avg_latency >= alerts.rules.latency_critical.threshold) {\n            const alertKey = `latency_${protocol}`;\n            if (!alerts.active[alertKey]) {\n                const alert = createAlert('system_critical', {\n                    metric: `${protocol.toUpperCase()} latency`,\n                    value: data.avg_latency,\n                    unit: 'ms',\n                    threshold: alerts.rules.latency_critical.threshold\n                });\n                alerts.active[alertKey] = alert;\n                newAlerts.push(alert);\n            }\n        }\n    });\n    \n    return newAlerts;\n}\n\nfunction processEquipmentMetrics(equipment) {\n    const newAlerts = [];\n    \n    // Check for high error rates across all equipment\n    const totalDevices = equipment.total_devices || 0;\n    const errorDevices = equipment.error || 0;\n    \n    if (totalDevices > 0) {\n        const errorRate = (errorDevices / totalDevices) * 100;\n        \n        if (errorRate > 15) { // More than 15% error rate\n            const alertKey = 'equipment_error_rate';\n            if (!alerts.active[alertKey]) {\n                const alert = createAlert('equipment_degradation', {\n                    equipmentId: 'multiple',\n                    errorRate: errorRate,\n                    totalDevices: totalDevices,\n                    errorDevices: errorDevices\n                });\n                alerts.active[alertKey] = alert;\n                newAlerts.push(alert);\n            }\n        }\n    }\n    \n    return newAlerts;\n}\n\nfunction resolveAlerts(currentData) {\n    const resolvedAlerts = [];\n    \n    Object.entries(alerts.active).forEach(([key, alert]) => {\n        let shouldResolve = false;\n        \n        switch (alert.type) {\n            case 'system_critical':\n                if (key === 'cpu_critical' && currentData.system.cpu_usage < alerts.rules.cpu_critical.threshold - 5) {\n                    shouldResolve = true;\n                } else if (key === 'memory_critical' && currentData.system.memory_usage < alerts.rules.memory_critical.threshold - 5) {\n                    shouldResolve = true;\n                } else if (key.startsWith('latency_')) {\n                    const protocol = key.split('_')[1];\n                    if (currentData.protocols[protocol] && \n                        currentData.protocols[protocol].avg_latency < alerts.rules.latency_critical.threshold - 100) {\n                        shouldResolve = true;\n                    }\n                }\n                break;\n                \n            case 'equipment_degradation':\n                if (key === 'equipment_error_rate') {\n                    const errorRate = (currentData.equipment.error / currentData.equipment.total_devices) * 100;\n                    if (errorRate < 10) {\n                        shouldResolve = true;\n                    }\n                }\n                break;\n        }\n        \n        if (shouldResolve) {\n            alert.status = 'resolved';\n            alert.resolvedAt = Date.now();\n            resolvedAlerts.push(alert);\n            \n            // Move to history\n            alerts.history.push(alert);\n            delete alerts.active[key];\n        }\n    });\n    \n    // Limit history size\n    if (alerts.history.length > 1000) {\n        alerts.history = alerts.history.slice(-1000);\n    }\n    \n    return resolvedAlerts;\n}\n\nif (msg.topic === 'performance_analysis') {\n    const analysis = msg.payload;\n    const allNewAlerts = [];\n    \n    // Process different types of performance data\n    if (analysis.report && analysis.report.current_state) {\n        // System metrics\n        const systemAlerts = processSystemMetrics(analysis.report.current_state.system);\n        allNewAlerts.push(...systemAlerts);\n        \n        // Protocol metrics\n        const protocolAlerts = processProtocolMetrics(analysis.report.current_state.protocols);\n        allNewAlerts.push(...protocolAlerts);\n        \n        // Equipment metrics\n        const equipmentAlerts = processEquipmentMetrics(analysis.report.current_state.equipment);\n        allNewAlerts.push(...equipmentAlerts);\n        \n        // Resolve alerts based on current state\n        const resolvedAlerts = resolveAlerts(analysis.report.current_state);\n    }\n    \n    // Process bottlenecks\n    if (analysis.report && analysis.report.bottlenecks) {\n        const bottleneckAlerts = processBottlenecks(analysis.report.bottlenecks);\n        allNewAlerts.push(...bottleneckAlerts);\n    }\n    \n    // Process predictions\n    if (analysis.predictions) {\n        const predictionAlerts = processPredictions(analysis.predictions);\n        allNewAlerts.push(...predictionAlerts);\n    }\n    \n    // Store updated alerts\n    flow.set('performanceAlerts', alerts);\n    \n    // Send alerts if any were created\n    if (allNewAlerts.length > 0) {\n        const outputs = allNewAlerts.map(alert => ({\n            topic: 'performance_alert',\n            payload: alert\n        }));\n        \n        // Also send summary\n        outputs.push({\n            topic: 'alert_summary',\n            payload: {\n                newAlerts: allNewAlerts.length,\n                activeAlerts: Object.keys(alerts.active).length,\n                criticalAlerts: Object.values(alerts.active).filter(a => a.severity === 'critical').length\n            }\n        });\n        \n        return outputs;\n    }\n} else if (msg.topic === 'acknowledge_alert') {\n    const alertId = msg.payload.alertId;\n    \n    Object.values(alerts.active).forEach(alert => {\n        if (alert.id === alertId) {\n            alert.acknowledged = true;\n            alert.acknowledgedBy = msg.payload.user || 'Unknown';\n            alert.acknowledgedAt = Date.now();\n        }\n    });\n    \n    flow.set('performanceAlerts', alerts);\n    \n    return {\n        topic: 'alert_acknowledged',\n        payload: { alertId: alertId }\n    };\n} else if (msg.topic === 'get_alerts') {\n    return {\n        topic: 'current_alerts',\n        payload: {\n            active: alerts.active,\n            history: alerts.history.slice(-50), // Last 50 historical alerts\n            summary: {\n                total: Object.keys(alerts.active).length,\n                critical: Object.values(alerts.active).filter(a => a.severity === 'critical').length,\n                warning: Object.values(alerts.active).filter(a => a.severity === 'warning').length\n            }\n        }\n    };\n}\n\nreturn null;",
    "outputs": 2,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 570,
    "y": 50,
    "wires": [["performance_notification"], ["performance_dashboard"]]
  },
  {
    "id": "performance_scheduler",
    "type": "inject",
    "z": "performance_monitor_1",
    "name": "Performance Monitor Schedule",
    "props": [
      {
        "p": "payload"
      },
      {
        "p": "topic",
        "vt": "str"
      }
    ],
    "repeat": "60",
    "crontab": "",
    "once": true,
    "onceDelay": 0.1,
    "topic": "collect_metrics",
    "payload": "{}",
    "payloadType": "json",
    "x": 170,
    "y": 100,
    "wires": [["performance_collector"]]
  },
  {
    "id": "performance_notification",
    "type": "function",
    "z": "performance_monitor_1",
    "name": "Alert Notifications",
    "func": "// Send notifications for performance alerts\nif (msg.topic === 'performance_alert') {\n    const alert = msg.payload;\n    \n    // Format notification message\n    let notification = {\n        title: `Performance Alert - ${alert.severity.toUpperCase()}`,\n        message: alert.message,\n        severity: alert.severity,\n        timestamp: alert.timestamp,\n        data: {\n            alertId: alert.id,\n            type: alert.type,\n            details: alert.data\n        }\n    };\n    \n    // Add context based on alert type\n    switch (alert.type) {\n        case 'system_critical':\n            notification.action = 'Check system resources and consider scaling';\n            notification.urgency = 'immediate';\n            break;\n            \n        case 'bottleneck_detected':\n            notification.action = 'Review system configuration and optimize bottleneck';\n            notification.urgency = 'high';\n            break;\n            \n        case 'prediction_alert':\n            notification.action = 'Preventive action recommended before threshold is reached';\n            notification.urgency = 'medium';\n            break;\n            \n        case 'equipment_degradation':\n            notification.action = 'Check equipment connectivity and configuration';\n            notification.urgency = 'high';\n            break;\n    }\n    \n    return [\n        {\n            topic: 'send_email_alert',\n            payload: notification\n        },\n        {\n            topic: 'send_dashboard_notification',\n            payload: notification\n        },\n        {\n            topic: 'log_alert',\n            payload: notification\n        }\n    ];\n} else if (msg.topic === 'alert_summary') {\n    return {\n        topic: 'update_alert_counter',\n        payload: msg.payload\n    };\n}\n\nreturn null;",
    "outputs": 3,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 780,
    "y": 50,
    "wires": [["alert_email_sender"], ["alert_dashboard"], ["alert_logger"]]
  },
  {
    "id": "alert_email_sender",
    "type": "email",
    "z": "performance_monitor_1",
    "server": "smtp.gmail.com",
    "port": "465",
    "secure": true,
    "tls": true,
    "name": "Performance Alerts Email",
    "dname": "Performance Monitor",
    "x": 1020,
    "y": 20,
    "wires": []
  },
  {
    "id": "alert_dashboard",
    "type": "ui_notification",
    "z": "performance_monitor_1",
    "position": "top right",
    "highlight": "",
    "displayTime": "10",
    "confirm": false,
    "name": "Dashboard Alert",
    "x": 1010,
    "y": 50,
    "wires": []
  },
  {
    "id": "alert_logger",
    "type": "file",
    "z": "performance_monitor_1",
    "name": "Alert Log",
    "filename": "/tmp/performance_alerts.log",
    "appendNewline": true,
    "createDir": true,
    "overwriteFile": "false",
    "encoding": "utf8",
    "x": 990,
    "y": 80,
    "wires": [[]]
  },
  {
    "id": "performance_group",
    "type": "ui_group",
    "name": "Performance Monitor",
    "tab": "performance_tab",
    "order": 1,
    "disp": true,
    "width": "24",
    "collapse": false
  },
  {
    "id": "performance_tab",
    "type": "ui_tab",
    "name": "Performance",
    "icon": "dashboard",
    "order": 2,
    "disabled": false,
    "hidden": false
  }
]